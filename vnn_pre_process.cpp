/****************************************************************************
*   Generated by ACUITY 6.30.0
*   Match ovxlib 1.1.53
*
*   Neural Network appliction pre-process source file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "jpeglib.h"
#include "vsi_nn_pub.h"
#include "vnn_global.h"
#include "vnn_pre_process.h"

#define _BASETSD_H

void scale_bbox(const bbox_t* in, bbox_t* out, float scale, int img_w, int img_h)
{
    printf("DEBUG scale_bbox: scale=%.2f, image_size=%dx%d\n", scale, img_w, img_h);
    float cx = in->x + in->w / 2.0f;
    float cy = in->y + in->h / 2.0f;
    printf("  Original bbox center: (%.1f, %.1f)\n", cx, cy);
    
    float new_w = in->w * scale;
    float new_h = in->h * scale;
    printf("  New size: %.1f x %.1f (from %d x %d)\n", new_w, new_h, in->w, in->h);
    
    out->x = (int)(cx - new_w / 2.0f);
    out->y = (int)(cy - new_h / 2.0f);
    out->w = (int)new_w;
    out->h = (int)new_h;
    printf("  Before clamp: x=%d y=%d w=%d h=%d\n", out->x, out->y, out->w, out->h);
    
    // Clamp to image bounds
    if (out->x < 0) out->x = 0;
    if (out->y < 0) out->y = 0;
    if (out->x + out->w > img_w) out->w = img_w - out->x;
    if (out->y + out->h > img_h) out->h = img_h - out->y;
    printf("  After clamp: x=%d y=%d w=%d h=%d\n", out->x, out->y, out->w, out->h);
}

uint8_t* crop_image(const uint8_t* img, int img_w, int img_h, int channels, const bbox_t* bbox)
{
    if (bbox->w <= 0 || bbox->h <= 0) {
        printf("Invalid bbox size: w=%d h=%d\n", bbox->w, bbox->h);
        return NULL;
    }
    printf("Crop bbox: x=%d y=%d w=%d h=%d\n", bbox->x, bbox->y, bbox->w, bbox->h);
    int crop_w = bbox->w;
    int crop_h = bbox->h;
    uint8_t* crop = (uint8_t*)malloc(crop_w * crop_h * channels);
    if (!crop) return NULL;
    for (int y = 0; y < crop_h; ++y)
    {
        int src_y = bbox->y + y;
        if (src_y >= img_h) break;
        for (int x = 0; x < crop_w; ++x)
        {
            int src_x = bbox->x + x;
            if (src_x >= img_w) break;
            for (int c = 0; c < channels; ++c)
            {
                crop[(y * crop_w + x) * channels + c] =
                    img[(src_y * img_w + src_x) * channels + c];
            }
        }
    }
    return crop;
}

/*-------------------------------------------
                  Variable definitions
-------------------------------------------*/

/*{graph_input_idx, preprocess}*/
const static vsi_nn_preprocess_map_element_t* preprocess_map = NULL;

/*-------------------------------------------
                  Functions
-------------------------------------------*/
#define INPUT_META_NUM 1
static vnn_input_meta_t input_meta_tab[INPUT_META_NUM];
static void _load_input_meta()
{
    uint32_t i;
    for (i = 0; i < INPUT_META_NUM; i++)
    {
        memset(&input_meta_tab[i].image.preprocess,
            VNN_PREPRO_NONE, sizeof(int32_t) * VNN_PREPRO_NUM);
    }
        /* lid: input_117 */
    //input_meta_tab[0].image.preprocess[0] = VNN_PREPRO_NONE;
    input_meta_tab[0].image.preprocess[0] = VNN_PREPRO_REORDER;
    //input_meta_tab[0].image.preprocess[1] = VNN_PREPRO_SCALE;
    //input_meta_tab[0].image.preprocess[2] = VNN_PREPRO_MEAN;
    //input_meta_tab[0].image.preprocess[3] = VNN_PREPRO_STD; 
    input_meta_tab[0].image.reorder[0] = 2;
    input_meta_tab[0].image.reorder[1] = 1;
    input_meta_tab[0].image.reorder[2] = 0;
    // input_meta_tab[0].image.mean[0] = 0.406f*255.0f;
    // input_meta_tab[0].image.mean[1] = 0.456f*255.0f;
    // input_meta_tab[0].image.mean[2] = 0.485f*255.0f;
    // input_meta_tab[0].image.scale[0] = 1.0f;
    // input_meta_tab[0].image.scale[1] = 1.0f;
    // input_meta_tab[0].image.scale[2] = 1.0f;
    // input_meta_tab[0].image.std[0] = 0.225f;
    // input_meta_tab[0].image.std[1] = 0.224f;
    // input_meta_tab[0].image.std[2] = 0.229f;
}

static vsi_enum _get_file_type(const char *file_name)
{
    vsi_enum type = 0;
    const char *ptr;
    char sep = '.';
    uint32_t pos,n;
    char buff[32] = {0};

    ptr = strrchr(file_name, sep);
    pos = ptr - file_name;
    n = strlen(file_name) - (pos + 1);
    strncpy(buff, file_name+(pos+1), n);

    if(strcmp(buff, "jpg") == 0
        || strcmp(buff, "jpeg") == 0
        || strcmp(buff, "JPG") == 0
        || strcmp(buff, "JPEG") == 0 )
    {
        type = NN_FILE_JPG;
    }
    else if(strcmp(buff, "tensor") == 0
        || strcmp(buff, "txt") == 0)
    {
        char *qnt_suffix = ".qnt.tensor";
        ptr = strstr(file_name, qnt_suffix);
        if(ptr && strlen(qnt_suffix))
        {
            type = NN_FILE_QTENSOR;
        }
        else
        {
            type = NN_FILE_TENSOR;
        }
    }
    else if(strcmp(buff, "qtensor") == 0)
    {
        type = NN_FILE_QTENSOR;
    }
    else if(strcmp(buff, "bin") == 0
        || strcmp(buff, "dat") == 0)
    {
        type = NN_FILE_BINARY;
    }
    else
    {
        type = NN_FILE_NONE;
    }

    return type;
}

// Hàm resize ảnh RGB (bilinear interpolation) - OpenCV style
void resize_rgb_image_opencv_style(
    const uint8_t* src, int src_w, int src_h, int src_c,
    uint8_t* dst, int dst_w, int dst_h
) {
    printf("DEBUG resize_rgb_image_opencv_style: %dx%dx%d -> %dx%dx%d\n", 
           src_w, src_h, src_c, dst_w, dst_h, src_c);
    printf("  Scale factors: x=%.3f, y=%.3f\n", 
           (float)src_w / dst_w, (float)src_h / dst_h);
    
    for (int y = 0; y < dst_h; ++y) {
        // OpenCV mapping: không có pixel center alignment
        float src_y = (float)y * src_h / dst_h;
        int y0 = (int)src_y;
        int y1 = y0 + 1;
        float wy = src_y - y0;
        if (y0 < 0) y0 = 0;
        if (y1 >= src_h) y1 = src_h - 1;

        for (int x = 0; x < dst_w; ++x) {
            // OpenCV mapping: không có pixel center alignment
            float src_x = (float)x * src_w / dst_w;
            int x0 = (int)src_x;
            int x1 = x0 + 1;
            float wx = src_x - x0;
            if (x0 < 0) x0 = 0;
            if (x1 >= src_w) x1 = src_w - 1;

            for (int c = 0; c < src_c; ++c) {
                float v00 = src[(y0 * src_w + x0) * src_c + c];
                float v01 = src[(y0 * src_w + x1) * src_c + c];
                float v10 = src[(y1 * src_w + x0) * src_c + c];
                float v11 = src[(y1 * src_w + x1) * src_c + c];
                float val = (1 - wy) * ((1 - wx) * v00 + wx * v01)
                          + wy * ((1 - wx) * v10 + wx * v11);
                int ival = (int)(val + 0.5f);
                if (ival < 0) ival = 0;
                if (ival > 255) ival = 255;
                dst[(y * dst_w + x) * src_c + c] = (uint8_t)ival;
            }
        }
    }
}

static vsi_status _jpeg_to_bmp
    (
    FILE * inputFile,
    unsigned char* bmpData,
    vsi_size_t bmpWidth,
    vsi_size_t bmpHeight,
    vsi_size_t channel
    )
{
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
    JSAMPARRAY buffer;
    unsigned char *point = NULL;
    unsigned long width, height;
    unsigned short depth = 0;

    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_stdio_src(&cinfo,inputFile);
    jpeg_read_header(&cinfo,TRUE);

    cinfo.dct_method = JDCT_IFAST;

    if (bmpData == NULL)
    {
        return VSI_FAILURE;
    }
    else
    {
        jpeg_start_decompress(&cinfo);

        width  = cinfo.output_width;
        height = cinfo.output_height;
        depth  = cinfo.output_components;

        unsigned char* tempData = (unsigned char*)malloc(width * height * depth);
        
        if (!tempData) {
            jpeg_finish_decompress(&cinfo);
            jpeg_destroy_decompress(&cinfo);
            return VSI_FAILURE;
        }

        buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, width * depth, 1);
        point = tempData;

        while (cinfo.output_scanline < height)
        {
            jpeg_read_scanlines(&cinfo, buffer, 1);
            memcpy(point, *buffer, width * depth);
            point += width * depth;
        }

        jpeg_finish_decompress(&cinfo);
        jpeg_destroy_decompress(&cinfo);

        // Resize nếu cần
        if (width != bmpWidth || height != bmpHeight || depth != channel)
        {
            printf("Resize: goc=%lux%lux%u -> model=%lux%lux%u\n",
                width, height, depth, bmpWidth, bmpHeight, channel);
            // Sử dụng OpenCV style resize
            resize_rgb_image_opencv_style(tempData, width, height, depth, bmpData, bmpWidth, bmpHeight);
        }
        else
        {
            printf("No resize: %lux%lux%u\n", width, height, depth);
            memcpy(bmpData, tempData, width * height * depth);
        }

        free(tempData);
        return VSI_SUCCESS;
    }
}

static uint8_t *_float32_to_dtype
    (
    float *fdata,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_status status;
    uint8_t *data;
    vsi_size_t sz,i,stride;

    sz = vsi_nn_GetElementNum(tensor);
    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    if(stride == 0)
    {
        stride = 1;
    }
    data = (uint8_t *)malloc(stride * sz * sizeof(uint8_t));
    TEST_CHECK_PTR(data, final);
    memset(data, 0, stride * sz * sizeof(uint8_t));

    for(i = 0; i < sz; i++)
    {
        status = vsi_nn_Float32ToDtype(fdata[i], &data[stride * i], &tensor->attr.dtype);
        if(status != VSI_SUCCESS)
        {
            if(data)free(data);
            return NULL;
        }
    }

final:
    return data;
}

static float *_imageData_to_float32
    (
    uint8_t *bmpData,
    vsi_nn_tensor_t *tensor
    )
{
    float *fdata;
    vsi_size_t sz,i;

    fdata = NULL;
    sz = vsi_nn_GetElementNum(tensor);
    fdata = (float *)malloc(sz * sizeof(float));
    TEST_CHECK_PTR(fdata, final);

    for(i = 0; i < sz; i++)
    {
        fdata[i] = (float)bmpData[i];
    }

final:
    return fdata;
}

/*
    jpg file --> BMP data(dataformat: RGBRGBRGB...)
*/
static uint8_t *_decode_jpeg(
    const char *name,
    int *out_w,
    int *out_h,
    int *out_c
)
{
    FILE *bmpFile = fopen(name, "rb");
    if (!bmpFile) return NULL;

    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_stdio_src(&cinfo, bmpFile);
    jpeg_read_header(&cinfo, TRUE);
    jpeg_start_decompress(&cinfo);

    int width = cinfo.output_width;
    int height = cinfo.output_height;
    int channels = cinfo.output_components;

    uint8_t *bmpData = (uint8_t *)malloc(width * height * channels);
    if (!bmpData) {
        jpeg_finish_decompress(&cinfo);
        jpeg_destroy_decompress(&cinfo);
        fclose(bmpFile);
        return NULL;
    }

    JSAMPARRAY buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, width * channels, 1);
    uint8_t *point = bmpData;
    while (cinfo.output_scanline < height) {
        jpeg_read_scanlines(&cinfo, buffer, 1);
        memcpy(point, *buffer, width * channels);
        point += width * channels;
    }

    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);
    fclose(bmpFile);

    if (out_w) *out_w = width;
    if (out_h) *out_h = height;
    if (out_c) *out_c = channels;
    return bmpData;
}

static void _data_std
    (
    float *fdata,
    vnn_input_meta_t *meta,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_size_t s0,s1,s2;
    vsi_size_t i,j,offset;
    float val,std;

    s0 = tensor->attr.size[0];
    s1 = tensor->attr.size[1];
    s2 = tensor->attr.size[2];

    for(i = 0; i < s2; i++)
    {
        offset = s0 * s1 * i;
        std = meta->image.std[i];
        for(j = 0; j < s0 * s1; j++)
        {
            val = fdata[offset + j] * std;
            fdata[offset + j ] = val;
        }
    }

}

static void _data_scale
    (
    float *fdata,
    vnn_input_meta_t *meta,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_size_t s0,s1,s2;
    vsi_size_t i,j,offset;
    float val,scale;

    s0 = tensor->attr.size[0];
    s1 = tensor->attr.size[1];
    s2 = tensor->attr.size[2];
    for(i = 0; i < s2; i++)
    {
        offset = s0 * s1 * i;
        scale = meta->image.scale[i];
        for(j = 0; j < s0 * s1; j++)
        {
            val = fdata[offset + j] * scale;
            fdata[offset + j ] = val;
        }
    }

}

static void _data_mean
    (
    float *fdata,
    vnn_input_meta_t *meta,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_size_t s0,s1,s2;
    vsi_size_t i,j,offset;
    float val,mean;

    s0 = tensor->attr.size[0];
    s1 = tensor->attr.size[1];
    s2 = tensor->attr.size[2];

    for(i = 0; i < s2; i++)
    {
        offset = s0 * s1 * i;
        mean = meta->image.mean[i];
        for(j = 0; j < s0 * s1; j++)
        {
            val = fdata[offset + j] - mean;
            fdata[offset + j ] = val;
        }
    }

}

/*
    caffe: transpose + reorder
    tf: reorder
*/
static void _data_transform
    (
    float *fdata,
    vnn_input_meta_t *meta,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_size_t s0,s1,s2;
    vsi_size_t i,j,offset,sz,order;
    float * data;
    uint32_t * reorder;

    data = NULL;
    reorder = meta->image.reorder;
    s0 = tensor->attr.size[0];
    s1 = tensor->attr.size[1];
    s2 = tensor->attr.size[2];
    sz = vsi_nn_GetElementNum(tensor);
    data = (float *)malloc(sz * sizeof(float));
    TEST_CHECK_PTR(data, final);
    memset(data, 0, sizeof(float) * sz);

    for(i = 0; i < s2; i++)
    {
        if(s2 > 1 && reorder[i] <= s2)
        {
            order = reorder[i];
        }
        else
        {
            order = i;
        }

        offset = s0 * s1 * i;
        for(j = 0; j < s0 * s1; j++)
        {
            data[j + offset] = fdata[j * s2 + order];
        }
    }


    memcpy(fdata, data, sz * sizeof(float));
final:
    if(data)free(data);
}

static uint8_t *_get_binary_data
    (
    vsi_nn_tensor_t *tensor,
    const char *name
    )
{
    uint8_t *tensorData;
    vsi_size_t sz,stride,ret,total_sz;
    FILE *tensorFile;

    tensorData = NULL;
    tensorFile = fopen(name, "rb");
    TEST_CHECK_PTR(tensorFile, error);

    sz = vsi_nn_GetElementNum(tensor);
    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    if(stride == 0)
    {
        stride = 1;
    }
    total_sz = sz * stride;
    tensorData = (uint8_t *)malloc(total_sz * sizeof(uint8_t));
    TEST_CHECK_PTR(tensorData, error);

    memset(tensorData, 0, total_sz * sizeof(uint8_t));
    ret = fread(tensorData, 1, total_sz, tensorFile);
    if(ret != total_sz)
    {
        printf("Read %s fail\n", name);
        printf("read data %u != tensor sz %u\n", ret, total_sz);
        if(tensorData)free(tensorData);
        goto error;
    }

    if(tensorFile)fclose(tensorFile);
    return tensorData;
error:
    if(tensorFile)fclose(tensorFile);
    return NULL;
}

static uint8_t *_get_qtensor_data
    (
    vsi_nn_tensor_t *tensor,
    const char *name
    )
{
    vsi_size_t i = 0;
    float fval = 0.0;
    uint8_t *tensorData;
    vsi_size_t sz = 1,stride = 1;
    FILE *tensorFile;
    uint16_t uint16_temp_value = 0;
    int16_t int16_temp_value = 0;

    tensorData = NULL;
    tensorFile = fopen(name, "rb");
    TEST_CHECK_PTR(tensorFile, error);

    sz = vsi_nn_GetElementNum(tensor);
    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    if(stride == 0)
    {
        stride = 1;
    }
    tensorData = (uint8_t *)malloc(sz * stride * sizeof(uint8_t));
    TEST_CHECK_PTR(tensorData, error);
    memset(tensorData, 0, sz * stride * sizeof(uint8_t));

    for(i = 0; i < sz; i++)
    {
        if(fscanf( tensorFile, "%f ", &fval ) != 1)
        {
            printf("Read tensor file fail.\n");
            printf("Please check file lines or if the file contains illegal characters\n");
            goto error;
        }
        if(1 == stride)
        {
            if(VSI_NN_TYPE_INT8 == tensor->attr.dtype.vx_type)
                tensorData[i * stride] = (int8_t)fval;
            else
                tensorData[i * stride] = (uint8_t)fval;
        }
        else if(2 == stride)
        {
            if(VSI_NN_TYPE_INT16 == tensor->attr.dtype.vx_type)
            {
                int16_temp_value = (int16_t)fval;
                memcpy(tensorData + i * stride, &int16_temp_value, stride * sizeof(uint8_t));
            }
            else
            {
                uint16_temp_value = (uint16_t)fval;
                memcpy(tensorData + i * stride, &uint16_temp_value, stride * sizeof(uint8_t));
            }
        }
        else
        {
            printf("Do not support quant data with length of %u.\n", stride);
            goto error;
        }
    }

    if(tensorFile)fclose(tensorFile);
    return tensorData;
error:
    if(tensorFile)fclose(tensorFile);
    return NULL;
}

static uint8_t *_get_tensor_data
    (
    vsi_nn_tensor_t *tensor,
    const char *name
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_size_t i = 0;
    float fval = 0.0;
    uint8_t *tensorData;
    vsi_size_t sz = 1;
    vsi_size_t stride = 1;
    FILE *tensorFile;

    tensorData = NULL;
    tensorFile = fopen(name, "rb");
    TEST_CHECK_PTR(tensorFile, error);

    sz = vsi_nn_GetElementNum(tensor);
    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    if(stride ==0)
    {
        stride = 1;
    }
    tensorData = (uint8_t *)malloc(stride * sz * sizeof(uint8_t));
    TEST_CHECK_PTR(tensorData, error);
    memset(tensorData, 0, stride * sz * sizeof(uint8_t));

    for(i = 0; i < sz; i++)
    {
        if(fscanf( tensorFile, "%f ", &fval ) != 1)
        {
            printf("Read tensor file fail.\n");
            printf("Please check file lines or if the file contains illegal characters\n");
            goto error;
        }
        status = vsi_nn_Float32ToDtype(fval, &tensorData[stride * i], &tensor->attr.dtype);
        TEST_CHECK_STATUS(status, error);
    }

    if(tensorFile)fclose(tensorFile);
    return tensorData;
error:
    if(tensorFile)fclose(tensorFile);
    return NULL;
}

static uint8_t *_get_jpeg_data(
    vsi_nn_tensor_t *tensor,
    vnn_input_meta_t *meta,
    const char *filename,
    const bbox_t* bbox_list,
    int bbox_count
)
{
    uint8_t *bmpData = NULL, *crop = NULL, *resized = NULL, *usedData = NULL, *data = NULL;
    float *fdata = NULL;
    int w, h, c;
    uint32_t i;
    vsi_bool use_image_process = vnn_UseImagePreprocessNode();

    // Đọc ảnh gốc
    bmpData = _decode_jpeg(filename, &w, &h, &c);
    if (!bmpData) goto final;

    printf("=== DEBUG IMAGE PROCESSING ===\n");
    printf("Input image size: %d x %d x %d\n", w, h, c);

    int model_w = tensor->attr.size[0];
    int model_h = tensor->attr.size[1];
    int model_c = tensor->attr.size[2];
    printf("Target tensor size: %d x %d x %d\n", model_w, model_h, model_c);

    if (bbox_list && bbox_count > 0)
    {
        printf("BBox input: x=%d y=%d w=%d h=%d\n", bbox_list[0].x, bbox_list[0].y, bbox_list[0].w, bbox_list[0].h);
        bbox_t scaled_bbox;
        scale_bbox(&bbox_list[0], &scaled_bbox, 4.0f, w, h);
        printf("BBox after scale (4.0x): x=%d y=%d w=%d h=%d\n", scaled_bbox.x, scaled_bbox.y, scaled_bbox.w, scaled_bbox.h);
        crop = crop_image(bmpData, w, h, c, &scaled_bbox);
        free(bmpData);
        if (!crop) goto final;

        // Resize vùng crop về kích thước model
        resized = (uint8_t*)malloc(model_w * model_h * c);
        if (!resized) goto final;
        printf("Crop size before resize: %d x %d x %d\n", scaled_bbox.w, scaled_bbox.h, c);
        printf("Resize crop to tensor size: %d x %d x %d\n", model_w, model_h, c);
        // Sử dụng OpenCV style resize (giống cv2.resize mặc định)
        resize_rgb_image_opencv_style(crop, scaled_bbox.w, scaled_bbox.h, c, resized, model_w, model_h);
        free(crop);
        usedData = resized;
    }
    else
    {
        // Không crop, chỉ resize toàn bộ ảnh về kích thước model
        printf("No bbox provided - resizing entire image\n");
        resized = (uint8_t*)malloc(model_w * model_h * c);
        if (!resized) goto final;
        printf("Resize entire image: %d x %d x %d -> %d x %d x %d\n", w, h, c, model_w, model_h, c);
        // Sử dụng OpenCV style resize (giống cv2.resize mặc định)
        resize_rgb_image_opencv_style(bmpData, w, h, c, resized, model_w, model_h);
        free(bmpData);
        usedData = resized;
    }

    if(use_image_process)
    {
        printf("Using hardware image preprocessing node\n");
        data = usedData;
        goto final;
    }

    printf("Converting to float32 and applying preprocessing...\n");
    fdata = _imageData_to_float32(usedData, tensor);
    if (!fdata) goto final;

    for(i = 0; i < _cnt_of_array(meta->image.preprocess); i++)
    {
        switch (meta->image.preprocess[i])
        {
        case VNN_PREPRO_NONE:
            printf("Preprocess step %d: NONE\n", i);
            break;
        case VNN_PREPRO_REORDER:
            printf("Preprocess step %d: REORDER channels\n", i);
            _data_transform(fdata, meta, tensor);
            break;
        case VNN_PREPRO_MEAN:
            printf("Preprocess step %d: SUBTRACT MEAN\n", i);
            _data_mean(fdata, meta, tensor);
            break;
        case VNN_PREPRO_SCALE:
            printf("Preprocess step %d: SCALE (normalize)\n", i);
            _data_scale(fdata, meta, tensor);
            break;
        case VNN_PREPRO_STD:
            printf("Preprocess step %d: DIVIDE STD\n", i);
            _data_std(fdata, meta, tensor);
            break;
        default:
            printf("Preprocess step %d: UNKNOWN (%d)\n", i, meta->image.preprocess[i]);
            break;
        }
    }

    printf("Converting float32 to tensor dtype...\n");
    data = _float32_to_dtype(fdata, tensor);
    printf("=== END DEBUG IMAGE PROCESSING ===\n");

final:
    if(fdata) free(fdata);
    if(usedData) free(usedData);
    return data;
}

#define IMAGE_ADDR_ALIGN_START_SIZE 64
#define IMAGE_ADDR_ALIGN_BLOCK_SIZE 64

static uint8_t *buffer_img = NULL;
static uint8_t *buffer_img_align_addr = NULL;

static void _get_image_handle_buffer
    (
    vsi_size_t width,
    vsi_size_t height,
    vsi_size_t channels,
    vsi_size_t align_start_size,
    vsi_size_t align_block_size
    )
{
    vsi_size_t sz;
    uint64_t temp;

    sz = width * height * channels + align_start_size + align_block_size;
    buffer_img = (uint8_t *)malloc( sz * sizeof( uint8_t ) );
    memset(buffer_img, 0, sizeof( uint8_t ) * sz);

    temp = (uint64_t)(buffer_img) % align_start_size;
    if (temp == 0)
    {
        buffer_img_align_addr = buffer_img;
    }
    else
    {
        buffer_img_align_addr = buffer_img + align_start_size - temp;
    }
}

static vsi_status _handle_multiple_inputs
    (
    vsi_nn_graph_t *graph,
    uint32_t idx,
    const char *input_file,
    const bbox_t* bbox_list, 
    int bbox_count 
    )
{
    vsi_status status;
    vsi_nn_tensor_t *tensor;
    uint8_t *data;
    vnn_input_meta_t meta;
    vsi_enum fileType;
    char dumpInput[128];
    char *p1 = NULL;

    status = VSI_FAILURE;
    data = NULL;
    tensor = NULL;
    memset(&meta, 0, sizeof(vnn_input_meta_t));
    tensor = vsi_nn_GetTensor( graph, graph->input.tensors[idx] );
    meta = input_meta_tab[idx];
    fileType = _get_file_type(input_file);
    switch(fileType)
    {
    case NN_FILE_JPG:
        data = _get_jpeg_data(tensor, &meta, input_file, bbox_list, bbox_count);
        TEST_CHECK_PTR(data, final);
        break;
    case NN_FILE_TENSOR:
        data = _get_tensor_data(tensor, input_file);
        TEST_CHECK_PTR(data, final);
        break;
    case NN_FILE_QTENSOR:
        data = _get_qtensor_data(tensor, input_file);
        TEST_CHECK_PTR(data, final);
        break;
    case NN_FILE_BINARY:
        data = _get_binary_data(tensor, input_file);
        TEST_CHECK_PTR(data, final);
        break;
    default:
        printf("error input file type\n");
        break;
    }

    /* Copy the Pre-processed data to input tensor */
    status = vsi_nn_CopyDataToTensor(graph, tensor, data);
    TEST_CHECK_STATUS(status, final);

    /* Save the image data to file */
    p1 = getenv( "VSI_SAVE_FILE_TYPE");

    snprintf(dumpInput, sizeof(dumpInput), "input_%d.txt", idx);
    if((p1 == NULL) || (*p1 == '0'))
    {
        vsi_nn_SaveTensorToTextByFp32(graph, tensor, dumpInput, NULL);
    }
    else if(*p1 == '1')
    {
        vsi_nn_SaveTensorToText(graph, tensor, dumpInput, NULL);
    }
    else if(*p1 == '2')
    {
        snprintf(dumpInput, sizeof(dumpInput), "input_%d.dat", idx);
        vsi_nn_SaveTensorToBinary(graph, tensor, dumpInput);
    }
    else if(*p1 == '3')
    {
        vsi_nn_SaveTensorToTextByFp32(graph, tensor, dumpInput, NULL);
        snprintf(dumpInput, sizeof(dumpInput), "input_%d.dat", idx);
        vsi_nn_SaveTensorToBinary(graph, tensor, dumpInput);
    }
    else
    {
        vsi_nn_SaveTensorToTextByFp32(graph, tensor, dumpInput, NULL);
    }


    status = VSI_SUCCESS;
final:
    if(data)free(data);
    return status;
}

void vnn_ReleaseBufferImage()
{
    if (buffer_img) free(buffer_img);
    buffer_img = NULL;
}

vsi_bool vnn_UseImagePreprocessNode()
{
    int32_t use_img_process;
    char *use_img_process_s;
    use_img_process = 0; /* default is 0 */
    use_img_process_s = getenv("VSI_USE_IMAGE_PROCESS");
    if(use_img_process_s)
    {
        use_img_process = atoi(use_img_process_s);
    }
    if (use_img_process)
    {
        return TRUE;
    }
    return FALSE;
}

vsi_status vnn_PreProcessMinifasnetv1se
    (
    vsi_nn_graph_t *graph,
    const char **inputs,
    uint32_t input_num,
    bbox_t* bbox_list,
    int bbox_count
    )
{
    uint32_t i;
    vsi_status status;
    status = VSI_FAILURE;
    _load_input_meta();
    if(input_num != graph->input.num)
    {
        printf("Graph need %u inputs, but enter %u inputs!!!\n",
               graph->input.num, input_num);
        return status;
    }
    for(i = 0; i < input_num; i++)
    {
        status = _handle_multiple_inputs(graph, i, inputs[i], bbox_list, bbox_count);
        TEST_CHECK_STATUS(status, final);
    }

    status = VSI_SUCCESS;
final:
    return status;
}

vsi_status vnn_PreProcessMinifasnetv2
    (
    vsi_nn_graph_t *graph,
    const char **inputs,
    uint32_t input_num,
    bbox_t* bbox_list,
    int bbox_count
    )
{
    uint32_t i;
    vsi_status status;
    status = VSI_FAILURE;
    _load_input_meta();
    if(input_num != graph->input.num)
    {
        printf("Graph need %u inputs, but enter %u inputs!!!\n",
               graph->input.num, input_num);
        return status;
    }
    for(i = 0; i < input_num; i++)
    {
        status = _handle_multiple_inputs(graph, i, inputs[i], bbox_list, bbox_count);
        TEST_CHECK_STATUS(status, final);
    }

    status = VSI_SUCCESS;
final:
    return status;
}

vsi_size_t vnn_LoadFP32DataFromTextFile
    (
    const char * fname,
    uint8_t ** buffer_ptr,
    vsi_size_t * buffer_sz
    )
{
    float fval = 0.0;
    vsi_size_t i = 0;
    uint8_t * buffer = NULL;
    vsi_size_t item_ount = 0;
    vsi_size_t read_size = 0;
    vsi_size_t stride = sizeof(fval);
    FILE *fp = NULL;

    if(!fname || !buffer_ptr || !buffer_sz)
    {
        return read_size;
    }

    fp = fopen(fname, "rb");
    if(fp)
    {
        while(!feof(fp) && fscanf( fp, "%f ", &fval ) == 1)
        {
            item_ount++;
        }

        if(item_ount > 0)
        {
            read_size = item_ount * stride;
            buffer = (uint8_t *)malloc(read_size);
            if(buffer)
            {
                int fail_to_read = FALSE;

                VSI_FSEEK(fp, 0, SEEK_SET);
                for(i = 0; i < item_ount && !fail_to_read; i++)
                {
                    if(fscanf( fp, "%f ", (float *)&buffer[stride * i] ) != 1)
                    {
                        printf("Read tensor file fail.\n");
                        printf("Please check file lines or if the file contains illegal characters\n");
                        free(buffer);
                        fail_to_read = TRUE;
                        read_size = 0;
                        break;
                    }
                }

                if(!fail_to_read)
                {
                    *buffer_ptr = buffer;
                    *buffer_sz = read_size;
                }
            }
            else
            {
                read_size = 0;
                printf("Allocate memory fail!\n");
            }
        }
        else
        {
            printf("No available data found!\n");
        }
        fclose(fp);
    }
    else
    {
        printf("Fail to open %s\n", fname);
    }

    if(!read_size)
    {
        printf("Load data from %s fail!\n", fname);
    }

    return read_size;
}

vsi_size_t vnn_LoadRawDataFromBinaryFile
    (
    const char * fname,
    uint8_t ** buffer_ptr,
    vsi_size_t * buffer_sz
    )
{
    FILE * fp = NULL;
    vsi_size_t fsize = 0;
    vsi_size_t read_size = 0;
    uint8_t* buffer = NULL;

    if(!fname || !buffer_ptr || !buffer_sz)
    {
        return fsize;
    }

    fp = fopen(fname, "rb");
    if(fp)
    {
        fsize = VSI_FSEEK(fp, 0, SEEK_END);
        fsize = ftell(fp);

        buffer = (uint8_t *)malloc(fsize);
        if(buffer)
        {
            VSI_FSEEK(fp, 0, SEEK_SET);
            read_size = fread(buffer, 1, fsize, fp);
            if(read_size == fsize)
            {
                *buffer_ptr = buffer;
                *buffer_sz = read_size;
            }
            else
            {
                fsize = 0;
                free(buffer);
                buffer = NULL;
            }
        }
        else
        {
            fsize = 0;
            printf("Allocate memory fail!\n");
        }

        if(fp)
        {
            fclose(fp);
        }
    }

    if(!fsize)
    {
        printf("Load data from %s fail!\n", fname);
    }
    return fsize;
}

const vsi_nn_preprocess_map_element_t * vnn_GetPreProcessMap()
{
    return preprocess_map;
}

uint32_t vnn_GetPreProcessMapCount()
{
    if (preprocess_map == NULL)
        return 0;
    else
        return sizeof(preprocess_map) / sizeof(vsi_nn_preprocess_map_element_t);
}
