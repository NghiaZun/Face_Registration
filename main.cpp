/****************************************************************************
*   Generated by ACUITY 6.30.0
*   Match ovxlib 1.1.53
*
*   Neural Network application project entry file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fstream>
#ifdef __linux__
#include <time.h>
#include <inttypes.h>
#elif defined(_WIN32)
#include <windows.h>
#endif

#define _BASETSD_H

extern "C" {

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_minifasnetv2.h"
#include "vnn_minifasnetv1se.h"
}
#include <vector>
#include "vnn_pre_process.hpp"
#include "vnn_post_process.hpp"
#include <opencv2/opencv.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/videoio.hpp>
/*-------------------------------------------
        Macros and Variables
-------------------------------------------*/
#ifdef __linux__
#define VSI_UINT64_SPECIFIER PRIu64
#elif defined(_WIN32)
#define VSI_UINT64_SPECIFIER "I64u"
#endif

static float psmsVal, psusVal;
static uint64_t st, frames; // for FPS stat
std::string dirFile = "./FaceData/ResNet34/";
std::string idFile = "itri-id.txt";
std::string dataFile = "itri_data.csv";
std::string csv_filepath = dirFile + dataFile;
std::string id_file_path = dirFile + idFile;
std::vector<cv::Mat> croppedimg;

const int FRC_input_size = 160;
const int FRC_feature_size = 128;
const float OPT_thrshold=0.7; 
int catched = 0;

#define DETECT_DEBUG 1
#define ITRI_SW_VERSION "20241204.003"

#define DETECT_RESULT_IMPL 0

/*-------------------------------------------
                  Functions
-------------------------------------------*/
static uint64_t get_perf_count();
//Add support for MiniFasNetV2
static void vnn_ReleaseNeuralNetworkV2
    (
    vsi_nn_graph_t *graph
    )
{
    vnn_ReleaseMinifasnetv2( graph, TRUE );
    if (vnn_UseImagePreprocessNode())
    {
        vnn_ReleaseBufferImage();
    }
}

static vsi_status vnn_PostProcessNeuralNetworkV2
    (
    vsi_nn_graph_t *graph
    )
{
    return vnn_PostProcessMinifasnetv2( graph );
}

static vsi_status vnn_PreProcessNeuralNetworkV2
    (
    vsi_nn_graph_t *graph,
    int argc,
    char **argv,
    bbox_t* bbox_list,
    int bbox_count
    )
{
    /*
     * argv0:   execute file
     * argv1:   data file
     * argv2~n: inputs n file
     */
    const char *inputs[1];
    inputs[0] = argv[3];
    uint32_t input_num = 1;
    vsi_status status = VSI_FAILURE;

    status = vnn_PreProcessMinifasnetv2(graph, inputs, input_num, bbox_list, bbox_count);
    return status;
}

static vsi_nn_graph_t *vnn_CreateNeuralNetworkV2
    (
    const char *data_file_name
    )
{
    vsi_nn_graph_t *graph = NULL;
    uint64_t tmsStart, tmsEnd, msVal, usVal;

    tmsStart = get_perf_count();
    graph = vnn_CreateMinifasnetv2( data_file_name, NULL,
                      vnn_GetPreProcessMap(), vnn_GetPreProcessMapCount(),
                      vnn_GetPostProcessMap(), vnn_GetPostProcessMapCount() );
    TEST_CHECK_PTR(graph, final);

    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/1000000;
    usVal = (tmsEnd - tmsStart)/1000;
    printf("Create Neural Network V2: % " VSI_UINT64_SPECIFIER "ms or % " VSI_UINT64_SPECIFIER "us\n", msVal, usVal);
final:
    return graph;
}

static void vnn_ReleaseNeuralNetwork
    (
    vsi_nn_graph_t *graph
    )
{
    vnn_ReleaseMinifasnetv1se( graph, TRUE );
    if (vnn_UseImagePreprocessNode())
    {
        vnn_ReleaseBufferImage();
    }
}

static vsi_status vnn_PostProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph
    )
{
    return vnn_PostProcessMinifasnetv1se( graph );
}

#define BILLION                                 1000000000
static uint64_t get_perf_count()
{
#if defined(__linux__) || defined(__ANDROID__) || defined(__QNX__) || defined(__CYGWIN__)
    struct timespec ts;

    clock_gettime(CLOCK_MONOTONIC, &ts);

    return (uint64_t)((uint64_t)ts.tv_nsec + (uint64_t)ts.tv_sec * BILLION);
#elif defined(_WIN32) || defined(UNDER_CE)
    LARGE_INTEGER freq;
    LARGE_INTEGER ln;

    QueryPerformanceFrequency(&freq);
    QueryPerformanceCounter(&ln);

    return (uint64_t)(ln.QuadPart * BILLION / freq.QuadPart);
#endif
}

static vsi_status vnn_VerifyGraph
    (
    vsi_nn_graph_t *graph
    )
{
    vsi_status status = VSI_FAILURE;
    uint64_t tmsStart, tmsEnd, msVal, usVal;

    /* Verify graph */
    printf("Verify...\n");
    tmsStart = get_perf_count();
    status = vsi_nn_VerifyGraph( graph );
    TEST_CHECK_STATUS(status, final);
    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/1000000;
    usVal = (tmsEnd - tmsStart)/1000;
    printf("Verify Graph: % " VSI_UINT64_SPECIFIER"ms or %"VSI_UINT64_SPECIFIER"us\n", msVal, usVal);

final:
    return status;
}

static vsi_status vnn_ProcessGraph
    (
    vsi_nn_graph_t *graph
    )
{
    vsi_status status = VSI_FAILURE;
    int32_t i,loop;
    char *loop_s;
    uint64_t tmsStart, tmsEnd, sigStart, sigEnd;
    float msVal, usVal;

    status = VSI_FAILURE;
    loop = 1; /* default loop time is 1 */
    loop_s = getenv("VNN_LOOP_TIME");
    if(loop_s)
    {
        loop = atoi(loop_s);
    }

    /* Run graph */
    tmsStart = get_perf_count();
    printf("Start run graph [%d] times...\n", loop);
    for(i = 0; i < loop; i++)
    {
        sigStart = get_perf_count();
#ifdef VNN_APP_ASYNC_RUN
        status = vsi_nn_AsyncRunGraph( graph );
        if(status != VSI_SUCCESS)
        {
            printf("Async Run graph the %d time fail\n", i);
        }
        TEST_CHECK_STATUS( status, final );

        //do something here...

        status = vsi_nn_AsyncRunWait( graph );
        if(status != VSI_SUCCESS)
        {
            printf("Wait graph the %d time fail\n", i);
        }
#else
        status = vsi_nn_RunGraph( graph );
        if(status != VSI_SUCCESS)
        {
            printf("Run graph the %d time fail\n", i);
        }
#endif
        TEST_CHECK_STATUS( status, final );

        sigEnd = get_perf_count();
        msVal = (sigEnd - sigStart)/(float)1000000;
        usVal = (sigEnd - sigStart)/(float)1000;
        printf("Run the %u time: %.2fms or %.2fus\n", (i + 1), msVal, usVal);
    }
    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/(float)1000000;
    usVal = (tmsEnd - tmsStart)/(float)1000;
    printf("vxProcessGraph execution time:\n");
    printf("Total   %.2fms or %.2fus\n", msVal, usVal);
    printf("Average %.2fms or %.2fus\n", ((float)usVal)/1000/loop, ((float)usVal)/loop);

final:
    return status;
}

static vsi_status vnn_PreProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph,
    int argc,
    char **argv,
    bbox_t* bbox_list,
    int bbox_count
    )
{
    /*
     * argv0:   execute file
     * argv1:   data file
     * argv2~n: inputs n file
     */
    const char *inputs[1];
    inputs[0] = argv[3];
    uint32_t input_num = 1;
    vsi_status status = VSI_FAILURE;

    status = vnn_PreProcessMinifasnetv1se(graph, inputs, input_num, bbox_list, bbox_count);
    return status;
}

static vsi_nn_graph_t *vnn_CreateNeuralNetwork
    (
    const char *data_file_name
    )
{
    vsi_nn_graph_t *graph = NULL;
    uint64_t tmsStart, tmsEnd, msVal, usVal;

    tmsStart = get_perf_count();
    graph = vnn_CreateMinifasnetv1se( data_file_name, NULL,
                      vnn_GetPreProcessMap(), vnn_GetPreProcessMapCount(),
                      vnn_GetPostProcessMap(), vnn_GetPostProcessMapCount() );
    TEST_CHECK_PTR(graph, final);

    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/1000000;
    usVal = (tmsEnd - tmsStart)/1000;
    printf("Create Neural Network: %"VSI_UINT64_SPECIFIER"ms or %"VSI_UINT64_SPECIFIER"us\n", msVal, usVal);

final:
    return graph;
}

/*-------------------------------------------
                  Main Functions
-------------------------------------------*/
int main
    (
    int argc,
    char **argv
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_status status_v2 = VSI_FAILURE;
    vsi_nn_graph_t *graph_v1se = NULL;
    vsi_nn_graph_t *graph_v2 = NULL;
    const char *data_name_v1se = NULL;
    const char *data_name_v2 = NULL;

    vsi_nn_tensor_t* output_tensor_v1se = NULL;
    vsi_nn_tensor_t* output_tensor_v2 = NULL;
    vsi_size_t out_size = 0;

    if(argc < 3)
    {
        printf("Usage: %s data_file_v1se [data_file_v2] inputs...\n", argv[0]);
        printf("If data_file_v2 not provided, will use default minifasnetv2.nb\n");
        return -1;
    }

    data_name_v1se = (const char *)argv[1];
    
    data_name_v2 = (const char *)argv[2];

    #define MAX_BBOX 16
    int bbox_count = (argc - 3) / 4;
    bbox_t bbox_list[MAX_BBOX];
    for (int i = 0; i < bbox_count; ++i) {
        int base = 3 + i * 4;
        bbox_list[i].x = atoi(argv[base]);
        bbox_list[i].y = atoi(argv[base + 1]);
        bbox_list[i].w = atoi(argv[base + 2]);
        bbox_list[i].h = atoi(argv[base + 3]);
    }

    /* Create both neural networks */
    printf("=== Creating MiniFasNet V1SE ===\n");
    graph_v1se = vnn_CreateNeuralNetwork( data_name_v1se );
    TEST_CHECK_PTR( graph_v1se, final );

    printf("=== Creating MiniFasNet V2 ===\n");
    graph_v2 = vnn_CreateNeuralNetworkV2( data_name_v2 );
    TEST_CHECK_PTR( graph_v2, final );

    /* Verify both graphs */
    printf("=== Verifying V1SE Graph ===\n");
    status = vnn_VerifyGraph( graph_v1se );
    TEST_CHECK_STATUS( status, final);

    printf("=== Verifying V2 Graph ===\n");
    status_v2 = vnn_VerifyGraph( graph_v2 );
    TEST_CHECK_STATUS( status_v2, final);

    /* Pre process the image data for both models */
    printf("=== Pre-processing V1SE ===\n");
    status = vnn_PreProcessNeuralNetwork( graph_v1se, argc, argv, bbox_list, bbox_count);
    TEST_CHECK_STATUS( status, final );

    printf("=== Pre-processing V2 ===\n");
    status_v2 = vnn_PreProcessNeuralNetworkV2( graph_v2, argc, argv, bbox_list, bbox_count);
    TEST_CHECK_STATUS( status_v2, final );

    /* Process both graphs */
    printf("=== Processing V1SE Graph ===\n");
    status = vnn_ProcessGraph( graph_v1se );
    TEST_CHECK_STATUS( status, final );

    printf("=== Processing V2 Graph ===\n");
    status_v2 = vnn_ProcessGraph( graph_v2 );
    TEST_CHECK_STATUS( status_v2, final );

    if(VNN_APP_DEBUG)
    {
        /* Dump all node outputs */
        vsi_nn_DumpGraphNodeOutputs(graph_v1se, "./network_dump_v1se", NULL, 0, TRUE, VSI_NN_DIM_FMT_AUTO);
        vsi_nn_DumpGraphNodeOutputs(graph_v2, "./network_dump_v2", NULL, 0, TRUE, VSI_NN_DIM_FMT_AUTO);
    }

    /* Ensemble post processing */
    printf("=== Ensemble Post-processing ===\n");
    status = vnn_PostProcessAntiSpoofing( graph_v1se, graph_v2 );
    TEST_CHECK_STATUS( status, final );

    // Get ensemble output tensor for further use
    output_tensor_v1se = vsi_nn_GetTensor(graph_v1se, graph_v1se->output.tensors[0]);
    output_tensor_v2 = vsi_nn_GetTensor(graph_v2, graph_v2->output.tensors[0]);
    out_size = 0;

final:
    if(graph_v1se) vnn_ReleaseNeuralNetwork( graph_v1se );
    if(graph_v2) vnn_ReleaseNeuralNetworkV2( graph_v2 );
    fflush(stdout);
    fflush(stderr);
    return status;
}

