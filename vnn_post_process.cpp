/****************************************************************************
*   Generated by ACUITY 6.30.0
*   Match ovxlib 1.1.53
*
*   Neural Network appliction post-process source file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_post_process.hpp"

#define _BASETSD_H

/*-------------------------------------------
                  Variable definitions
-------------------------------------------*/

/*{graph_output_idx, postprocess}*/
const static vsi_nn_postprocess_map_element_t* postprocess_map = NULL;


/*-------------------------------------------
                  Functions
-------------------------------------------*/
void softmax(const float* input, float* output, vsi_size_t len)
{
    float max_val = input[0];
    for (vsi_size_t i = 1; i < len; ++i)
        if (input[i] > max_val) max_val = input[i];

    float sum = 0.0f;
    for (vsi_size_t i = 0; i < len; ++i)
    {
        output[i] = expf(input[i] - max_val);
        sum += output[i];
    }
    for (vsi_size_t i = 0; i < len; ++i)
    {
        output[i] /= sum;
    }
}

static vsi_bool get_top
    (
    float *pfProb,
    float *pfMaxProb,
    vsi_size_t *pMaxClass,
    vsi_size_t outputCount,
    vsi_size_t topNum
    )
{
    vsi_size_t i, j, k;

    #define MAX_TOP_NUM 20
    if (topNum > MAX_TOP_NUM) return FALSE;

    memset(pfMaxProb, 0xfe, sizeof(float) * topNum);
    memset(pMaxClass, 0xff, sizeof(vsi_size_t) * topNum);

    for (j = 0; j < topNum; j++)
    {
        for (i=0; i<outputCount; i++)
        {
            for (k=0; k < topNum; k ++)
            {
                if(i == pMaxClass[k])
                    break;
            }

            if (k != topNum)
                continue;

            if (pfProb[i] > *(pfMaxProb+j))
            {
                *(pfMaxProb+j) = pfProb[i];
                *(pMaxClass+j) = i;
            }
        }
    }

    return TRUE;
}

float* get_output_probabilities(vsi_nn_graph_t *graph, vsi_nn_tensor_t *tensor, vsi_size_t* out_size)
{
    vsi_size_t i, sz, stride;
    float *buffer = NULL;
    uint8_t *tensor_data = NULL;

    sz = 1;
    for(i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }
    *out_size = sz;

    stride = (vsi_size_t)vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    if(stride == 0)
    {
        stride = 1;
    }
    tensor_data = (uint8_t *)vsi_nn_ConvertTensorToData(graph, tensor);
    buffer = (float *)malloc(sizeof(float) * sz);

    for(i = 0; i < sz; i++)
    {
        vsi_nn_DtypeToFloat32(&tensor_data[stride * i], &buffer[i], &tensor->attr.dtype);
    }

    if(tensor_data) vsi_nn_Free(tensor_data);
    return buffer; // bạn phải free(buffer) ở bước sau khi dùng xong
}

static vsi_status show_top5
    (
    vsi_nn_graph_t *graph,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_size_t i,sz,stride;
    float *buffer = NULL;
    uint8_t *tensor_data = NULL;
    vsi_size_t MaxClass[5];
    float fMaxProb[5];
    vsi_size_t topk = 5;

    sz = 1;
    for(i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }

    if(topk > sz)
        topk = sz;

    stride = (vsi_size_t)vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    if(stride == 0)
    {
        stride = 1;
    }
    tensor_data = (uint8_t *)vsi_nn_ConvertTensorToData(graph, tensor);
    buffer = (float *)malloc(sizeof(float) * sz);

    for(i = 0; i < sz; i++)
    {
        status = vsi_nn_DtypeToFloat32(&tensor_data[stride * i], &buffer[i], &tensor->attr.dtype);
    }

    if (!get_top(buffer, fMaxProb, MaxClass, sz, topk))
    {
        printf("Fail to show result.\n");
        goto final;
    }

    printf(" --- Top%d ---\n", topk);
    for(i = 0; i< topk; i++)
    {
        printf("%3d: %8.6f\n", MaxClass[i], fMaxProb[i]);
    }
    status = VSI_SUCCESS;

final:
    if(tensor_data)vsi_nn_Free(tensor_data);
    if(buffer)free(buffer);
    return status;
}

vsi_status vnn_PostProcessMinifasnetv2(vsi_nn_graph_t *graph)
{
    vsi_status status = VSI_FAILURE;
    vsi_nn_tensor_t *output_tensor = NULL;
    float *probs = NULL;
    vsi_size_t sz = 1, i;
    if (!graph) return status;

    output_tensor = vsi_nn_GetTensor(graph, graph->output.tensors[0]);
    if (!output_tensor) return status;

    for (i = 0; i < output_tensor->attr.dim_num; ++i)
        sz *= output_tensor->attr.size[i];

    probs = get_output_probabilities(graph, output_tensor, &sz);
    if (!probs) return status;

    float *softmax_probs = (float*)malloc(sizeof(float) * sz);
    if (!softmax_probs) {
        free(probs);
        return status;
    }
    softmax(probs, softmax_probs, sz);

    printf("MiniFasNetV2 Output (softmax):\n");
    for (i = 0; i < sz; ++i)
        printf("Class %u: %.6f\n", (unsigned)i, softmax_probs[i]);

    // Optionally show top-5
    show_top5(graph, output_tensor);

    free(probs);
    free(softmax_probs);
    status = VSI_SUCCESS;
    return status;
}

vsi_status vnn_PostProcessMinifasnetv1se(vsi_nn_graph_t *graph)
{
    vsi_status status = VSI_FAILURE;
    vsi_nn_tensor_t *output_tensor = NULL;
    float *probs = NULL;
    vsi_size_t sz = 1, i;
    if (!graph) return status;

    output_tensor = vsi_nn_GetTensor(graph, graph->output.tensors[0]);
    if (!output_tensor) return status;

    for (i = 0; i < output_tensor->attr.dim_num; ++i)
        sz *= output_tensor->attr.size[i];

    probs = get_output_probabilities(graph, output_tensor, &sz);
    if (!probs) return status;

    float *softmax_probs = (float*)malloc(sizeof(float) * sz);
    if (!softmax_probs) {
        free(probs);
        return status;
    }
    softmax(probs, softmax_probs, sz);

    printf("MiniFasNetV1SE Output (softmax):\n");
    for (i = 0; i < sz; ++i)
        printf("Class %u: %.6f\n", (unsigned)i, softmax_probs[i]);

    // Optionally show top-5
    show_top5(graph, output_tensor);

    free(probs);
    free(softmax_probs);
    status = VSI_SUCCESS;
    return status;
}

static void save_output_data(vsi_nn_graph_t *graph)
{
    uint32_t i;
#define _DUMP_FILE_LENGTH 1028
#define _DUMP_SHAPE_LENGTH 128
    char filename[_DUMP_FILE_LENGTH] = {0}, shape[_DUMP_SHAPE_LENGTH] = {0};
    vsi_nn_tensor_t *tensor;

    for(i = 0; i < graph->output.num; i++)
    {
        tensor = vsi_nn_GetTensor(graph, graph->output.tensors[i]);
        vsi_nn_ShapeToString( tensor->attr.size, tensor->attr.dim_num,
            shape, _DUMP_SHAPE_LENGTH, FALSE );
        snprintf( filename, _DUMP_FILE_LENGTH, "output%u_%s.txt", i, shape );
        {
            char *p = NULL;
            p = getenv( "VSI_SAVE_FILE_TYPE" );
            if( ( p == NULL ) || ( *p == '0' ) )
            {
                vsi_nn_SaveTensorToTextByFp32( graph, tensor, filename, NULL );
            }
            else if( *p == '1' )
            {
                vsi_nn_SaveTensorToText( graph, tensor, filename, NULL );
            }
            else if( *p == '2' )
            {
                snprintf( filename, _DUMP_FILE_LENGTH, "output%u_%s.dat", i, shape );
                vsi_nn_SaveTensorToBinary( graph, tensor, filename );
            }
            else if(*p == '3')
            {
                vsi_nn_SaveTensorToTextByFp32(graph, tensor, filename, NULL);
                snprintf(filename, _DUMP_FILE_LENGTH, "output%u_%s.dat", i, shape);
                vsi_nn_SaveTensorToBinary(graph, tensor, filename);
            }
            else
            {
                vsi_nn_SaveTensorToTextByFp32( graph, tensor, filename, NULL );
            }
        }

    }
}


vsi_status vnn_PostProcessAntiSpoofing
    (
    vsi_nn_graph_t *graph_v1se,
    vsi_nn_graph_t *graph_v2
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_nn_tensor_t *tensor_v1se = NULL, *tensor_v2 = NULL;
    float *data_v1se = NULL, *data_v2 = NULL;
    float *ensemble_probs = NULL;
    float *final_probs = NULL;      // <-- move declaration here
    vsi_size_t sz_v1se = 1, sz_v2 = 1, i;
    float max_prob = 0.0f;          // <-- move declaration here
    vsi_size_t max_class = 0;       // <-- move declaration here

    printf("[%s()]::[%d] Ensemble post-processing\n", __FUNCTION__, __LINE__);

    // 1. Lấy output tensor từ V1SE
    tensor_v1se = vsi_nn_GetTensor(graph_v1se, graph_v1se->output.tensors[0]);
    if (!tensor_v1se) {
        printf("Cannot get V1SE output tensor!\n");
        goto final;
    }

    // 2. Lấy output tensor từ V2
    tensor_v2 = vsi_nn_GetTensor(graph_v2, graph_v2->output.tensors[0]);
    if (!tensor_v2) {
        printf("Cannot get V2 output tensor!\n");
        goto final;
    }

    // 3. Tính số lượng phần tử cho V1SE
    for(i = 0; i < tensor_v1se->attr.dim_num; i++)
    {
        sz_v1se *= tensor_v1se->attr.size[i];
    }

    // 4. Tính số lượng phần tử cho V2
    for(i = 0; i < tensor_v2->attr.dim_num; i++)
    {
        sz_v2 *= tensor_v2->attr.size[i];
    }

    // 5. Kiểm tra kích thước output có khớp nhau không
    if (sz_v1se != sz_v2) {
        printf("Error: V1SE output size (%u) != V2 output size (%u)\n", sz_v1se, sz_v2);
        goto final;
    }

    // 6. Lấy dữ liệu raw từ cả 2 model (chưa softmax)
    data_v1se = get_output_probabilities(graph_v1se, tensor_v1se, &sz_v1se);
    if (!data_v1se) {
        printf("Cannot get V1SE output data!\n");
        goto final;
    }

    data_v2 = get_output_probabilities(graph_v2, tensor_v2, &sz_v2);
    if (!data_v2) {
        printf("Cannot get V2 output data!\n");
        goto final;
    }

    // 7. Tính trung bình ensemble: (logits_v1se + logits_v2) / 2
    ensemble_probs = (float*)malloc(sizeof(float) * sz_v1se);
    if (!ensemble_probs) goto final;

    for(i = 0; i < sz_v1se; i++)
    {
        ensemble_probs[i] = (data_v1se[i] + data_v2[i]) / 2.0f;
    }

    // 8. Áp dụng softmax lên ensemble logits
    final_probs = (float*)malloc(sizeof(float) * sz_v1se);
    if (!final_probs) {
        goto final;
    }
    
    softmax(ensemble_probs, final_probs, sz_v1se);

    // 9. In ra kết quả ensemble
    printf("=== ENSEMBLE RESULTS ===\n");
    for(i = 0; i < sz_v1se; i++)
    {
        printf("Class [%u]: V1SE=%.6f, V2=%.6f, Ensemble=%.6f\n", 
               i, data_v1se[i], data_v2[i], final_probs[i]);
    }

    // 10. Tìm class có xác suất cao nhất
    max_prob = final_probs[0];
    max_class = 0;
    for(i = 1; i < sz_v1se; i++)
    {
        if (final_probs[i] > max_prob) {
            max_prob = final_probs[i];
            max_class = i;
        }
    }

    printf("Final Prediction: Class %u with probability %.6f\n", max_class, max_prob);

    status = VSI_SUCCESS;

final:
    if(final_probs) free(final_probs);
    if(data_v1se) free(data_v1se);
    if(data_v2) free(data_v2);
    if(ensemble_probs) free(ensemble_probs);
    return status;
}

const vsi_nn_postprocess_map_element_t * vnn_GetPostProcessMap()
{
    return postprocess_map;
}

uint32_t vnn_GetPostProcessMapCount()
{
    if (postprocess_map == NULL)
       return 0;
    else
        return sizeof(postprocess_map) / sizeof(vsi_nn_postprocess_map_element_t);
}